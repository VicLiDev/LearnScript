###############################################################################
# 通用 多目标 + 子目录 Makefile Demo
###############################################################################

# 工作目录
WK_DIR       := $(CURDIR)
CUR_MKF_FILE := $(lastword $(MAKEFILE_LIST))
CUR_MKF_DIR  := $(dir $(CUR_MKF_FILE))

# 打印信息
$(info [WorkDir]  $(WK_DIR))
$(info [Makefile] $(CUR_MKF_FILE))
$(info [Mkf Dir ] $(CUR_MKF_DIR))

###############################################################################
# 基本设置
###############################################################################

CC      := gcc
CFLAGS  := -Wall -Wextra
MCRODEF := -DMCRO_DEMO -DMCRO_DEMO2=\"mcro2\"

# 通用 include / lib 目录（可被所有 target 使用）
INCLUDE_DIRS := $(CUR_MKF_DIR)/include \
				/usr/local/include

LIB_DIRS := $(CUR_MKF_DIR)/lib \
			/usr/local/lib

LIBS := m \
		pthread

# 转换为命令行形式
CPPFLAGS += $(addprefix -I, $(INCLUDE_DIRS))
LDFLAGS  += $(addprefix -L, $(LIB_DIRS))
LDLIBS   += $(addprefix -l, $(LIBS))

###############################################################################
# 目录与目标定义
###############################################################################

# 源码目录（如果以后你想放到 src/ 可直接改这里）
SRC_DIR := $(CUR_MKF_DIR)

# 子目录
SUBDIRS := $(CUR_MKF_DIR)/subdir1 \
           $(CUR_MKF_DIR)/subdir2

# 要生成的可执行文件
TARGETS := $(CUR_MKF_DIR)/demo \
           $(CUR_MKF_DIR)/demo2

###############################################################################
# 每个可执行文件的源文件定义
###############################################################################

# demo 目标的源文件
# SRCs = $(wildcard *.c)
SRC_DEMO = $(CUR_MKF_DIR)/mfunc.c \
		   $(CUR_MKF_DIR)/mfunc2.c \
		   $(CUR_MKF_DIR)/demo.c
OBJ_DEMO  := $(SRC_DEMO:.c=.o)

# demo2 目标的源文件
SRC_DEMO2 := $(SRC_DIR)/mfunc.c \
             $(SRC_DIR)/mfunc2.c \
             $(SRC_DIR)/demo2.c
OBJ_DEMO2 := $(SRC_DEMO2:.c=.o)


###############################################################################
# 伪目标
###############################################################################

.PHONY: all clean $(SUBDIRS)

all: $(TARGETS) $(SUBDIRS)

###############################################################################
# 链接规则（每个可执行文件独立配置）
###############################################################################
# $@ 在模式规则中，表示规则中的目标文件集。如果有多个目标，那么，"$@"就是匹配
#    目标中模式定义的集合。
# $< 依赖目标中的第一个目标名字。如果依赖目标是以模式（即"%"）定义的，那么"$<"将
#    是符合模式的一系列的文件集。注意，其是一个一个取出来的。
# $^ 所有的依赖目标的集合。以空格分隔。如果在依赖目标中有多个重复的，那个这个
#    变量会去除重复的依赖目标，只保留一份。
#
# 注意：
# 这里 $@ 的集合 和 $</$^ 的集合 含义是不一样的：
# $@ 的集合，意义在于使用规则模式时，用作推导，每次推导使用 $@ 中的一个元素，类似for循环
# $</$^ 的集合，与规则模式和推导无关，如果用在推导模式中使用，每次推导的值都是一样的，不会像 $@ 一样推导
#
# 使用模式规则时，一条指令可以多次执行的条件是:
# 1. 有多个目标文件，模式规则多次执行与依赖文件无关，只与目标文件有关
# 2. 目标文件被需要，即有其他目标依赖当前的目标文件，如果不被需要，则不会推导执行
# 验证demo如下：
# obj = obja objb
# src = test.c
#
# all : $(obj)
#
# # $(obj) : $(src)
# $(obj) :
# 	@echo ""
# 	@echo "obj: "$(obj)
# 	@echo '@: '$@
# 	@echo '^: '$^
# 	@echo '<: '$<

# demo 可执行文件
$(CUR_MKF_DIR)/demo: $(OBJ_DEMO)
	$(CC) -o $@ $^ $(LDFLAGS) $(LDLIBS)

# demo2 可执行文件
$(CUR_MKF_DIR)/demo2: $(OBJ_DEMO2)
	$(CC) -o $@ $^ $(LDFLAGS) $(LDLIBS)

###############################################################################
# 通用编译规则（使用 pattern rule）
###############################################################################

# 将所有 .c 编译成 .o

%.o: %.c
	$(CC) $(CFLAGS) $(CPPFLAGS) $(MCRODEF) -c $< -o $@

###############################################################################
# 子目录递归构建
###############################################################################
# 在一个主 Makefile 中执行子目录中的 Makefile，你可以使用 make -C 命令，它会切换
# 到子目录执行那个目录下的 Makefile。
#
# 使用 $(MAKE) 而不是直接用 make 是更安全的方式，它能传递一些有用的变量（如并行
# 标志 -j）
#
# make -f 是 make 命令的一个选项，用来指定使用哪个 Makefile 文件来执行构建任务。

$(SUBDIRS):
	$(MAKE) -C $@

###############################################################################
# 运行测试
###############################################################################
.PHONY: tests
tests: $(TARGETS)
	@echo "=== Running all tests ==="
	@for t in $(TARGETS); do \
		echo "-- Running $$t"; \
		$$t; \
		echo ""; \
	done

###############################################################################
# 清理
###############################################################################

clean:
	$(RM) $(OBJ_DEMO) $(OBJ_DEMO2)
	$(RM) $(TARGETS)
	@for d in $(SUBDIRS); do \
		$(MAKE) -C $$d clean; \
	done


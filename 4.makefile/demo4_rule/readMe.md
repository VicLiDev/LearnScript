
## Make 中规则类型总结

| 类型                 | 示例                                    | 特点                                 |
| -------------------- | --------------------------------------- | ------------------------------------ |
| **显式规则**         | `target: dependencies`                  | 明确指定构建方式                     |
| **模式规则**         | `%.o : %.c`                             | 使用 `%` 表示通配，批量处理文件      |
| **静态模式规则**     | `targets: target-pattern : dep-pattern` | 更复杂规则构建，适合多个目标共享模式 |
| **伪目标（PHONY）**  | `.PHONY: clean`                         | 防止目标与实际文件冲突               |
| **默认规则**         | `all:`                                  | Make 的入口点                        |
| **内置规则（隐含）** | 无需写明                                | GCC 内建规则，如 `%.o: %.c` 自动应用 |


## `%` 详解

`%` 是 Makefile 中非常核心、强大的语法之一，通常用于**模式匹配（模式规则）**，
类似于 Shell 或正则中的通配符，但更具结构化和特殊行为。

---

### `%` 的用途概览

| 用法类别             | 场景示例                               | 描述                       |
| -------------------- | -------------------------------------- | -------------------------- |
| **模式规则**         | `%.o: %.c`                             | 匹配 `.o` 和 `.c` 文件转换 |
| **静态模式规则**     | `targets: target-pattern: dep-pattern` | 配置复杂目标规则           |
| **字符串替换函数中** | `$(patsubst %.c, %.o, main.c)`         | 字符替换与生成目标         |

---

### `%` 在模式规则中的核心意义

> `%` 表示**通配任意文件主名**（即不包含扩展名的部分）

例如：

```makefile
%.o: %.c
	gcc -c $< -o $@
```

这个规则的意思是：
* 如果尝试构建 `main.o`
* Make 会尝试查找 `main.c` 是否存在
* 如果存在，它就使用这个规则来构建

**重点**：
* `%` 只匹配路径中**一个“段”**
* `%` 左右必须同时存在，不能只有一边使用（否则可能不生效）

---

### 模式规则中 `%` 的例子

#### 示例 1：基础编译规则

```makefile
%.o: %.c
	gcc -c $< -o $@
```

构建时：

```bash
make hello.o
```

Make 会寻找 `hello.c` 并执行：

```bash
gcc -c hello.c -o hello.o
```

---

#### 示例 2：加路径（推荐）

```makefile
build/%.o: src/%.c
	mkdir -p build
	gcc -Wall -c $< -o $@
```

构建 `build/main.o` 时会匹配 `src/main.c`。

* `%` 匹配的是 `main`
* `build/%` → 目标路径
* `src/%`  → 源路径

---

### `%` 用在字符串替换函数中

函数如 `patsubst` 中 `%` 非常常用：

```makefile
SRCS := foo.c bar.c
OBJS := $(patsubst %.c, %.o, $(SRCS))
# OBJS = foo.o bar.o
```

它表示“把 .c 换成 .o”。

---

### 示例项目：Makefile 使用 `%` 的各种方式

```makefile
# 源文件与对象文件
SRC_DIR := src
OBJ_DIR := build
SRCS := $(wildcard $(SRC_DIR)/*.c)
OBJS := $(patsubst $(SRC_DIR)/%.c, $(OBJ_DIR)/%.o, $(SRCS))

# 默认目标
all: myapp

# 链接目标程序
myapp: $(OBJS)
	$(CC) -o $@ $^

# 使用 % 匹配 src/*.c 到 build/*.o
$(OBJ_DIR)/%.o: $(SRC_DIR)/%.c
	@echo "使用 % 匹配：构建 $@ from $<"
	@mkdir -p $(OBJ_DIR)
	$(CC) -c $< -o $@

clean:
	rm -rf $(OBJ_DIR) myapp

.PHONY: all clean
```

---

### `%` 的陷阱与误区

| 问题                           | 原因                        | 解决                       |
| ------------------------------ | --------------------------- | -------------------------- |
| `%` 匹配多个路径段？           | ❌ 不行，只能匹配一段文件名 | 拆分路径组合               |
| 模式规则不触发                 | 没有目标试图匹配 `%`        | 确保你调用了 `make 目标名` |
| 同时定义静态模式规则和模式规则 | 会互相冲突                  | 二选一                     |

---

### 小结：% 是什么？

| 场景            | `%` 表示                   |
| --------------- | -------------------------- |
| 模式规则        | 目标和依赖中的**通配主名** |
| patsubst 等函数 | 结构化字符串替换           |

---

### 实战建议

* 使用 `%` 搭配 `src/%.c` 和 `build/%.o` 是构建 C 项目的最佳实践。
* 避免对同一目标重复使用静态和模式规则。
* 用 `patsubst` 批量生成目标时 `%` 替换非常高效。

